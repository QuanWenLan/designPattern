> 《设计模式之禅》中的设计原则
#### 单一职责原则
不要存在多于一个导致类变更的原因。通俗的说，即一个类只负责一项职责。


#### 里氏替换原则
##### 继承的好处和缺点
优点：
- 代码共享，减少创建类的工作量，每个子类都拥有父类的方法和属性；
- 提高代码的重用性；
- 子类可以形似父类，但又异于父类，“龙生龙，凤生凤，老鼠生来会打洞”是说子拥有
  父的“种”，“世界上没有两片完全相同的叶子”是指明子与父的不同；
- 提高代码的可扩展性，实现父类的方法就可以“为所欲为”了，君不见很多开源框架的
  扩展接口都是通过继承父类来完成的；
- 提高产品或项目的开放性

缺点：
- 继承是侵入性的。只要继承，就必须拥有父类的所有属性和方法；
- 降低代码的灵活性。子类必须拥有父类的属性和方法，让子类自由的世界中多了些约
  束；
- 增强了耦合性。当父类的常量、变量和方法被修改时，需要考虑子类的修改，而且在
  缺乏规范的环境下，这种修改可能带来非常糟糕的结果——大段的代码需要重构。

**里氏替换原则是用来解决子类父类继承的问题，其目的是保持父类方法不被覆盖**。  
第一种定义：如果对每一个类型为S的对象o1，都有类型为T的对象o2，使得以T定义的所有程序P在所有的对象o1都代换成o2时，程序P的行为没有发生变
化，那么类型S是类型T的子类型。  

第二种定义：**所有引用基类的地方必须能透明地使用其子类的对象**。 
第二个定义是最清晰明确的，通俗点讲，**只要父类能出现的地方子类就可以出现，而且替换为子类也不会产生任何错误或异常**，使用者可能根本就不需要知道是父类还是子类。
但是，**反过来就不行了，有子类出现的地方，父类未必就能适应**。  
4层含义：  
 * 1.子类必须完全实现父类的方法
 * 2.子类可以有自己的个性，子类可以出现的地方父类就未必可以出现
 * 3.覆盖或实现父类的方法时输入参数可以被放大
 * 4.覆写或实现父类的方法时输出结果可以被缩小
 
如果子类不能完整地实现父类的方法，或者父类的某些方法在子类中已经发 生“畸变”，则建议断开父子继承关系，采用依赖、聚集、组合等关系代替继承。  


#### 依赖倒置原则
 * 高层模块不应该依赖低层模块，两者都应该依赖其抽象；
 * 抽象不应该依赖细节；
 * 细节应该依赖抽象。

那什么是抽象？什么又是细节呢？在Java语言中，抽象就是指接口或抽象类，两者都是不能直接被实例化的；细节就是实
现类，实现接口或继承抽象类而产生的类就是细节，其特点就是可以直接被实例化，也就是
可以加上一个关键字new产生一个对象。  
依赖倒置原则在Java语言中的表现就是：
* 模块间的依赖通过抽象发生，实现类之间不发生直接的依赖关系，其依赖关系是通过接口或抽象类产生的；
* 接口或抽象类不依赖于实现类；
* 实现类依赖接口或抽象类。


#### 接口隔离原则
2种定义  
- 客户端不应该依赖它不需要的接口。（那依赖什么？依赖它需要的接口，客户端需要什么接口就提供什么接口，把不需要的接口剔除掉，那就需要对接口进行细化，保
  证其纯洁性）
- 类间的依赖关系应该建立在最小的接口上。（它要求是最小的接口，也是要求接口细化，接口纯洁，与第一个定义如出一辙）

我们可以把这两个定义概括为一句话：建立单一接口，不要建立臃肿庞大的接口。再通
俗一点讲：接口尽量细化，同时接口中的方法尽量少。  

接口隔离原则与单一职责的审视角度是不相同的，**单一职责要求的是类和接口职责单一，注重的是职责，这是业务逻辑上的划分**，
而**接口隔离原则要求接口的方法尽量少**。例如一个接口的职责可能包含10个方法，这10个方法都放在一个接口
中，并且提供给多个模块访问，各个模块按照规定的权限来访问，在系统外通过文档约
束“不使用的方法不要访问”，按照单一职责原则是允许的，按照接口隔离原则是不允许的，
因为它要求“尽量使用多个专门的接口”。专门的接口指什么？就是指提供给每个模块的都应
该是单一接口，提供给几个模块就应该有几个接口，而不是建立一个庞大的臃肿的接口，容
纳所有的客户端访问。


#### 开闭原则 
一个软件实体如类、模块和函数应该对扩展开放，对修改关闭。    

软件实体应该对扩展开放，对修改关闭，其含义是说一个软件实体应该通过扩展来实现变化，而不是通过修改已有的代码来实现变化。  

开闭 原则告诉我们应尽量通过扩展软件实体的行为来实现变化，而不是通过修改已有的代码来完
成变化，它是为软件实体的未来事件而制定的对现行开发设计进行约束的一个原则。

开闭原则对扩展开放，对修改关闭，并不意味着不做任何修改，低层模块的变
更，必然要有高层模块进行耦合，否则就是一个孤立无意义的代码片段。


#### 迪米特法则
迪米特法则（Law of Demeter，LoD）也称为最少知识原则（Least Knowledge
Principle，LKP），虽然名字不同，但描述的是同一个规则：**一个对象应该对其他对象有最
少的了解。通俗地讲，一个类应该对自己需要耦合或调用的类知道得最少，你（被耦合或调
用的类）的内部是如何复杂都和我没关系，那是你的事情，我就知道你提供的这么多public
方法，我就调用这么多，其他的我一概不关心**。







